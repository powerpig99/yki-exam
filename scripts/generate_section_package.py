#!/usr/bin/env python3
from __future__ import annotations

import argparse
import re
from datetime import date
from pathlib import Path
from typing import Iterable


def read_lines(path: Path) -> list[str]:
    return path.read_text(encoding="utf-8").splitlines()


def extract_section(lines: list[str], section_title: str) -> list[str]:
    wanted = f"## {section_title}".strip()
    start = None
    for i, line in enumerate(lines):
        if line.strip() == wanted:
            start = i
            break
    if start is None:
        raise ValueError(f"section not found: {section_title!r}")

    end = len(lines)
    for i in range(start + 1, len(lines)):
        if lines[i].startswith("## "):
            end = i
            break
    return lines[start:end]


def block_after_heading(section_lines: list[str], heading: str) -> list[str]:
    idx = None
    for i, line in enumerate(section_lines):
        if line.strip() == heading.strip():
            idx = i
            break
    if idx is None:
        return []
    out: list[str] = []
    for line in section_lines[idx + 1 :]:
        if line.startswith("### "):
            break
        out.append(line)
    return out


def extract_dialog_numbers(section_lines: list[str]) -> list[int]:
    nums: list[int] = []
    rx = re.compile(r"^### Dialogi (\d+)")
    for line in section_lines:
        m = rx.match(line)
        if m:
            nums.append(int(m.group(1)))
    return sorted(nums)


def extract_block(section_lines: list[str], heading: str) -> list[str]:
    idx = None
    for i, line in enumerate(section_lines):
        if line.strip() == heading.strip():
            idx = i
            break
    if idx is None:
        return []

    out = [section_lines[idx]]
    for line in section_lines[idx + 1 :]:
        if line.startswith("### "):
            break
        out.append(line)
    return out


def first_nonempty(lines: Iterable[str]) -> str:
    for line in lines:
        if line.strip():
            return line.strip()
    return ""


def numbered_items(lines: list[str]) -> list[str]:
    out: list[str] = []
    for line in lines:
        if re.match(r"^\d+\.\s+", line):
            out.append(line.strip())
    return out


def parse_letter_topics(lines: list[str]) -> list[tuple[str, list[str]]]:
    topics: list[tuple[str, list[str]]] = []
    cur_title: str | None = None
    cur_lines: list[str] = []

    def flush() -> None:
        nonlocal cur_title, cur_lines
        if cur_title is not None:
            topics.append((cur_title, cur_lines[:]))
        cur_title = None
        cur_lines = []

    for line in lines:
        s = line.strip()
        if re.match(r"^\*\*[A-ZÅÄÖ]\.\s", s):
            flush()
            cur_title = s.strip("*")
            continue
        if cur_title is not None:
            if s:
                cur_lines.append(line)
    flush()
    return topics


def clean_prompt_line(line: str) -> str:
    s = line.strip()
    if s.startswith("- "):
        s = s[2:].strip()
    return s


def parse_writing_tasks(section_lines: list[str]) -> list[tuple[str, list[str]]]:
    idx = None
    for i, line in enumerate(section_lines):
        if line.strip() == "### Kirjoittaminen":
            idx = i
            break
    if idx is None:
        return []

    block = section_lines[idx + 1 :]
    tasks: list[tuple[str, list[str]]] = []
    current_name: str | None = None
    current_lines: list[str] = []

    for line in block:
        if line.startswith("## ") or line.startswith("### "):
            break
        if line.startswith("#### "):
            if current_name is not None:
                tasks.append((current_name, current_lines[:]))
            current_name = line.replace("#### ", "", 1).strip()
            current_lines = []
            continue
        if current_name is not None:
            current_lines.append(line)

    if current_name is not None:
        tasks.append((current_name, current_lines[:]))
    return tasks


def normalize_slug(s: str) -> str:
    s = s.lower().strip()
    s = re.sub(r"[^a-z0-9]+", "_", s)
    s = re.sub(r"_+", "_", s).strip("_")
    return s


def build_output(source_path: Path, section_title: str, section_lines: list[str]) -> str:
    today = date.today().isoformat()
    out: list[str] = []
    out.append(f"# {section_title} - Regenerated Study Package Scaffold")
    out.append("")
    out.append("Generated by `scripts/generate_section_package.py`.")
    out.append("")
    out.append("Source of truth:")
    out.append(f"- `{source_path}`")
    out.append(f"- section: `## {section_title}`")
    out.append(f"- generated: `{today}`")
    out.append("")
    out.append("This file is scaffold-only: complete source prompts + reusable answer slots.")
    out.append("")
    out.append("---")
    out.append("")

    # 1) Source snapshot (verbatim)
    out.append("## 1) Source Snapshot (Verbatim)")
    out.append("")
    out.extend(section_lines)
    out.append("")
    out.append("---")
    out.append("")

    # 2) Structured scaffold
    out.append("## 2) Structured Scaffold (Fill Answers Here)")
    out.append("")

    # Dialogs
    out.append("### 2.1 Puhuminen: Dialogit")
    out.append("")
    dialog_nums = extract_dialog_numbers(section_lines)
    for num in dialog_nums:
        d_block = extract_block(section_lines, f"### Dialogi {num}")
        m_block = extract_block(section_lines, f"### MALLI: Dialogi {num}")
        context = first_nonempty(d_block[1:]) if d_block else ""

        out.append(f"#### SPK-DIA-{num:02d}")
        if context:
            out.append(f"**Konteksti (lähteestä):** {context}")
        out.append("")
        out.append("**Tehtävärunko (lähteestä):**")
        if d_block:
            for line in d_block[1:]:
                if line.strip():
                    out.append(line.strip())
        out.append("")
        out.append("**MALLI-taulukko (lähteestä):**")
        if m_block:
            out.extend(m_block[1:] if m_block[0].startswith("### ") else m_block)
        out.append("")
        out.append("**Mallivastaukset (täytä):**")
        out.append("1. ...")
        out.append("2. ...")
        out.append("3. ...")
        out.append("4. ...")
        out.append("5. ...")
        out.append("")

    # Reagointi
    out.append("### 2.2 Puhuminen: Reagointi")
    out.append("")
    reagointi_lines = block_after_heading(section_lines, "### Reagointi")
    for i, item in enumerate(numbered_items(reagointi_lines), start=1):
        prompt = re.sub(r"^\d+\.\s+", "", item)
        out.append(f"#### SPK-REA-{i:02d}")
        out.append(f"**Tehtävä (lähteestä):** {prompt}")
        out.append("**Mallivastaus (täytä):**")
        out.append("...")
        out.append("")

    # Kertominen
    out.append("### 2.3 Puhuminen: Kertominen")
    out.append("")
    kertominen_block = block_after_heading(section_lines, "### Kertominen")
    for title, prompts in parse_letter_topics(kertominen_block):
        letter = title.split(".", 1)[0]
        out.append(f"#### SPK-KER-01{letter}")
        out.append(f"**Aihe (lähteestä):** {title}")
        out.append("**Kysymykset (lähteestä):**")
        for p in prompts:
            out.append(f"- {clean_prompt_line(p)}")
        out.append("**Mallipuhe (täytä):**")
        out.append("...")
        out.append("")

    # Mielipide
    out.append("### 2.4 Puhuminen: Mielipide")
    out.append("")
    mielipide_block = block_after_heading(section_lines, "### Mielipide")
    for title, prompts in parse_letter_topics(mielipide_block):
        letter = title.split(".", 1)[0]
        out.append(f"#### SPK-MIE-01{letter}")
        out.append(f"**Aihe (lähteestä):** {title}")
        out.append("**Kysymykset (lähteestä):**")
        for p in prompts:
            out.append(f"- {clean_prompt_line(p)}")
        out.append("**Mallivastaus (täytä):**")
        out.append("...")
        out.append("")

    # Writing
    out.append("### 2.5 Kirjoittaminen")
    out.append("")
    writing_tasks = parse_writing_tasks(section_lines)
    for idx, (name, body) in enumerate(writing_tasks, start=1):
        wid = f"WRT-TSK-{idx:02d}"
        out.append(f"#### {wid} - {name}")
        out.append("**Tehtävänanto (lähteestä):**")
        for line in body:
            if line.strip():
                out.append(line.strip())
        out.append("**Malliteksti (täytä):**")
        out.append("...")
        out.append("")

    out.append("---")
    out.append("")
    out.append("## 3) Regeneration Rules")
    out.append("")
    out.append("- If source changes, regenerate this file from source. Do not patch old scaffolds.")
    out.append("- Fill answers only in Section 2, keep Section 1 as immutable snapshot for traceability.")
    out.append("- Keep IDs stable (`SPK-*`, `WRT-*`) for translation/TTS/subtitle sync.")
    out.append("")

    return "\n".join(out).rstrip() + "\n"


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate section study package scaffold from source markdown.")
    parser.add_argument("--source", required=True, help="Path to source markdown (e.g. yki_highway_to_hill.md)")
    parser.add_argument("--section", required=True, help="Section title without ## prefix")
    parser.add_argument("--out", required=True, help="Output markdown path")
    args = parser.parse_args()

    source_path = Path(args.source).expanduser().resolve()
    out_path = Path(args.out).expanduser().resolve()

    lines = read_lines(source_path)
    section_lines = extract_section(lines, args.section)
    output = build_output(source_path, args.section, section_lines)

    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(output, encoding="utf-8")

    print(f"Wrote: {out_path}")


if __name__ == "__main__":
    main()
